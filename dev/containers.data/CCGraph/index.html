<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>CCGraph (containers.data.CCGraph)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">containers.data</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">CCGraph</span></h1></header><h2>Simple Graph Interface</h2><p>A collections of algorithms on (mostly read-only) graph structures.
The user provides her own graph structure as a <code class="code">('v, 'e) CCGraph.t</code>,
where <code class="code">'v</code> is the type of vertices and <code class="code">'e</code> the type of edges
(for instance, <code class="code">'e = ('v * 'v)</code> is perfectly fine in many cases).</p><p>Such a <code class="code">('v, 'e) CCGraph.t</code> structure is a record containing
three functions: two relate edges to their origin and destination,
and one maps vertices to their outgoing edges.
This abstract notion of graph makes it possible to run the algorithms
on any user-specific type that happens to have a graph structure.</p><p>Many graph algorithms here take a sequence of vertices as input.
If the user only has a single vertex (e.g., for a topological sort
from a given vertex), she can use <code class="code">Seq.return x</code> to build a sequence
of one element.</p><p><b>status: unstable</b></p><ul class="at-tag"><li><span class="at-tag since">Since</span>: 0.12</li></ul><h3>Sequence Helpers</h3><div class="spec type" id="type-sequence"><a href="#type-sequence" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a sequence</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit</code><code></code></div><div class="doc"><p>A sequence of items of type <code class="code">'a</code>, possibly infinite</p></div></div><div class="spec type" id="type-sequence_once"><a href="#type-sequence_once" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a sequence_once</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <a href="index.html#type-sequence">sequence</a></code><code></code></div><div class="doc"><p>Sequence that should be used only once</p></div></div><div class="spec exception" id="exception-Sequence_once"><a href="#exception-Sequence_once" class="anchor"></a><div class="def exception"><code><span class="keyword">exception </span></code><code><span class="exception">Sequence_once</span></code></div><div class="doc"><p>Raised when a sequence meant to be used once is used several times.</p></div></div><div class="spec module" id="module-Seq"><a href="#module-Seq" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Seq/index.html">Seq</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><h3>Interfaces for graphs</h3><p>This interface is designed for oriented graphs with labels on edges</p><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('v, 'e) t</code><code><span class="keyword"> = </span><span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'e</span><span class="keyword"> * </span><span class="type-var">'v</span>) <a href="index.html#type-sequence">sequence</a></code><code></code></div><div class="doc"><p>Directed graph with vertices of type <code class="code">'v</code> and edges labeled with <code class="code">e'</code></p></div></div><div class="spec type" id="type-graph"><a href="#type-graph" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('v, 'e) graph</code><code><span class="keyword"> = </span>(<span class="type-var">'v</span>, <span class="type-var">'e</span>) <a href="index.html#type-t">t</a></code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-make"><a href="#val-make" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>make : (<span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'e</span><span class="keyword"> * </span><span class="type-var">'v</span>) <a href="index.html#type-sequence">sequence</a>) <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'v</span>, <span class="type-var">'e</span>) <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Make a graph by providing the children function.</p></div></div><div class="spec type" id="type-tag_set"><a href="#type-tag_set" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'v tag_set</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-tag_set.get_tag" class="anchored"><td class="def field"><a href="#type-tag_set.get_tag" class="anchor"></a><code>get_tag : <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> bool;</code></td></tr><tr id="type-tag_set.set_tag" class="anchored"><td class="def field"><a href="#type-tag_set.set_tag" class="anchor"></a><code>set_tag : <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** Set tag for the given element *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><h3>Tags</h3><p>Mutable tags from values of type <code class="code">'v</code> to tags of type <code class="code">bool</code></p></div></div><div class="spec type" id="type-table"><a href="#type-table" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('k, 'a) table</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-table.mem" class="anchored"><td class="def field"><a href="#type-table.mem" class="anchor"></a><code>mem : <span class="type-var">'k</span> <span class="keyword">&#8209;&gt;</span> bool;</code></td></tr><tr id="type-table.find" class="anchored"><td class="def field"><a href="#type-table.find" class="anchor"></a><code>find : <span class="type-var">'k</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>;</code></td><td class="doc"><p>(** </p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Not_found</span>: if element not added before</li></ul><p> *)</p></td></tr><tr id="type-table.add" class="anchored"><td class="def field"><a href="#type-table.add" class="anchor"></a><code>add : <span class="type-var">'k</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> unit;</code></td><td class="doc"><p>(** Erases previous binding *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><h3>Table</h3><p>Mutable table with keys <code class="code">'k</code> and values <code class="code">'a</code></p></div></div><div class="spec type" id="type-set"><a href="#type-set" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a set</code><code><span class="keyword"> = </span>(<span class="type-var">'a</span>, unit) <a href="index.html#type-table">table</a></code><code></code></div><div class="doc"><p>Mutable set</p></div></div><div class="spec val" id="val-mk_table"><a href="#val-mk_table" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mk_table : eq:(<span class="type-var">'k</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'k</span> <span class="keyword">&#8209;&gt;</span> bool) <span class="keyword">&#8209;&gt;</span> ?&#8288;hash:(<span class="type-var">'k</span> <span class="keyword">&#8209;&gt;</span> int) <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'a</span>) <a href="index.html#type-table">table</a></code></div><div class="doc"><p>Default implementation for <a href="index.html#type-table">table</a>: a <span class="xref-unresolved" title="unresolved reference to &quot;Hashtbl.t&quot;">Hashtbl.t</span>.</p></div></div><div class="spec val" id="val-mk_map"><a href="#val-mk_map" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mk_map : cmp:(<span class="type-var">'k</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'k</span> <span class="keyword">&#8209;&gt;</span> int) <span class="keyword">&#8209;&gt;</span> unit <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'k</span>, <span class="type-var">'a</span>) <a href="index.html#type-table">table</a></code></div><div class="doc"><p>Use a <span class="xref-unresolved" title="unresolved reference to &quot;Map.S&quot;"><a href="index.html#module-Map">Map</a>.S</span> underneath.</p></div></div><h3>Bags of vertices</h3><div class="spec type" id="type-bag"><a href="#type-bag" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a bag</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-bag.push" class="anchored"><td class="def field"><a href="#type-bag.push" class="anchor"></a><code>push : <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> unit;</code></td></tr><tr id="type-bag.is_empty" class="anchored"><td class="def field"><a href="#type-bag.is_empty" class="anchor"></a><code>is_empty : unit <span class="keyword">&#8209;&gt;</span> bool;</code></td></tr><tr id="type-bag.pop" class="anchored"><td class="def field"><a href="#type-bag.pop" class="anchor"></a><code>pop : unit <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>;</code></td><td class="doc"><p>(** raises some exception is empty *)</p></td></tr></table><code>}</code><code></code></div><div class="doc"><p>Bag of elements of type <code class="code">'a</code></p></div></div><div class="spec val" id="val-mk_queue"><a href="#val-mk_queue" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mk_queue : unit <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bag">bag</a></code></div><div class="doc"></div></div><div class="spec val" id="val-mk_stack"><a href="#val-mk_stack" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mk_stack : unit <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bag">bag</a></code></div><div class="doc"></div></div><div class="spec val" id="val-mk_heap"><a href="#val-mk_heap" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mk_heap : leq:(<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> bool) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-bag">bag</a></code></div><div class="doc"><p><code class="code">mk_heap ~leq</code> makes a priority queue where <code class="code">leq x y = true</code> means that
<code class="code">x</code> is smaller than <code class="code">y</code> and should be prioritary.</p></div></div><h3>Traversals</h3><div class="spec module" id="module-Traverse"><a href="#module-Traverse" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Traverse/index.html">Traverse</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><h3>Cycles</h3><div class="spec val" id="val-is_dag"><a href="#val-is_dag" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>is_dag : tbl:<span class="type-var">'v</span> <a href="index.html#type-set">set</a> <span class="keyword">&#8209;&gt;</span> eq:(<span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> bool) <span class="keyword">&#8209;&gt;</span> graph:(<span class="type-var">'v</span>, <span class="type-var">_</span>) <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <a href="index.html#type-sequence">sequence</a> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p><code class="code">is_dag ~graph vs</code> returns <code class="code">true</code> if the subset of <code class="code">graph</code> reachable
from <code class="code">vs</code> is acyclic.</p><ul class="at-tag"><li><span class="at-tag since">Since</span>: 0.18</li></ul></div></div><h3>Topological Sort</h3><div class="spec exception" id="exception-Has_cycle"><a href="#exception-Has_cycle" class="anchor"></a><div class="def exception"><code><span class="keyword">exception </span></code><code><span class="exception">Has_cycle</span></code></div><div class="doc"></div></div><div class="spec val" id="val-topo_sort"><a href="#val-topo_sort" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>topo_sort : eq:(<span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> bool) <span class="keyword">&#8209;&gt;</span> ?&#8288;rev:bool <span class="keyword">&#8209;&gt;</span> tbl:<span class="type-var">'v</span> <a href="index.html#type-set">set</a> <span class="keyword">&#8209;&gt;</span> graph:(<span class="type-var">'v</span>, <span class="type-var">'e</span>) <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <a href="index.html#type-sequence">sequence</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> list</code></div><div class="doc"><p><code class="code">topo_sort ~graph seq</code> returns a list of vertices <code class="code">l</code> where each
element of <code class="code">l</code> is reachable from <code class="code">seq</code>.
The list is sorted in a way such that if <code class="code">v -&gt; v'</code> in the graph, then
<code class="code">v</code> comes before <code class="code">v'</code> in the list (i.e. has a smaller index).
Basically <code class="code">v -&gt; v'</code> means that <code class="code">v</code> is smaller than <code class="code">v'</code>.
See <a href="https://en.wikipedia.org/wiki/Topological_sorting">wikipedia</a>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">eq</span>: equality predicate on vertices (default <code class="code">(=)</code>).</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">rev</span>: if true, the dependency relation is inverted (<code class="code">v -&gt; v'</code> means
<code class="code">v'</code> occurs before <code class="code">v</code>).</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Has_cycle</span>: if the graph is not a DAG.</li></ul></div></div><div class="spec val" id="val-topo_sort_tag"><a href="#val-topo_sort_tag" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>topo_sort_tag : eq:(<span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> bool) <span class="keyword">&#8209;&gt;</span> ?&#8288;rev:bool <span class="keyword">&#8209;&gt;</span> tags:<span class="type-var">'v</span> <a href="index.html#type-tag_set">tag_set</a> <span class="keyword">&#8209;&gt;</span> graph:(<span class="type-var">'v</span>, <span class="type-var">'e</span>) <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <a href="index.html#type-sequence">sequence</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> list</code></div><div class="doc"><p>Same as <a href="index.html#val-topo_sort">topo_sort</a> but uses an explicit tag set.</p></div></div><h3>Lazy Spanning Tree</h3><div class="spec module" id="module-Lazy_tree"><a href="#module-Lazy_tree" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Lazy_tree/index.html">Lazy_tree</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec val" id="val-spanning_tree"><a href="#val-spanning_tree" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>spanning_tree : tbl:<span class="type-var">'v</span> <a href="index.html#type-set">set</a> <span class="keyword">&#8209;&gt;</span> graph:(<span class="type-var">'v</span>, <span class="type-var">'e</span>) <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'v</span>, <span class="type-var">'e</span>) <a href="Lazy_tree/index.html#type-t">Lazy_tree.t</a></code></div><div class="doc"><p><code class="code">spanning_tree ~graph v</code> computes a lazy spanning tree that has <code class="code">v</code>
as a root. The table <code class="code">tbl</code> is used for the memoization part.</p></div></div><div class="spec val" id="val-spanning_tree_tag"><a href="#val-spanning_tree_tag" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>spanning_tree_tag : tags:<span class="type-var">'v</span> <a href="index.html#type-tag_set">tag_set</a> <span class="keyword">&#8209;&gt;</span> graph:(<span class="type-var">'v</span>, <span class="type-var">'e</span>) <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'v</span>, <span class="type-var">'e</span>) <a href="Lazy_tree/index.html#type-t">Lazy_tree.t</a></code></div><div class="doc"></div></div><h3>Strongly Connected Components</h3><div class="spec type" id="type-scc_state"><a href="#type-scc_state" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'v scc_state</code><code></code><code></code></div><div class="doc"><p>Hidden state for <a href="index.html#val-scc">scc</a>.</p></div></div><div class="spec val" id="val-scc"><a href="#val-scc" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>scc : tbl:(<span class="type-var">'v</span>, <span class="type-var">'v</span> <a href="index.html#type-scc_state">scc_state</a>) <a href="index.html#type-table">table</a> <span class="keyword">&#8209;&gt;</span> graph:(<span class="type-var">'v</span>, <span class="type-var">'e</span>) <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <a href="index.html#type-sequence">sequence</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> list <a href="index.html#type-sequence_once">sequence_once</a></code></div><div class="doc"><p>Strongly connected components reachable from the given vertices.
Each component is a list of vertices that are all mutually reachable
in the graph.
The components are explored in a topological order (if C1 and C2 are
components, and C1 points to C2, then C2 will be yielded before C1).
Uses <a href="https://en.wikipedia.org/wiki/Tarjan's_strongly_connected_components_algorithm">Tarjan's algorithm</a>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">tbl</span>: table used to map nodes to some hidden state.</li><li><span class="at-tag raise">Raises</span> <span class="module-path">Sequence_once</span>: if the result is iterated on more than once.</li></ul></div></div><h3>Pretty printing in the DOT (graphviz) format</h3><p>Example (print divisors from <code class="code">42</code>):</p><pre><code class="code">      let open CCGraph in
      let open Dot in
      with_out &quot;/tmp/truc.dot&quot;
        (fun out -&gt;
           pp ~attrs_v:(fun i -&gt; [`Label (string_of_int i)]) ~graph:divisors_graph out 42
        )</code></pre><div class="spec module" id="module-Dot"><a href="#module-Dot" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Dot/index.html">Dot</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><h3>Mutable Graph</h3><div class="spec type" id="type-mut_graph"><a href="#type-mut_graph" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>('v, 'e) mut_graph</code><code></code><code><span class="keyword"> = </span></code><code>{</code><table class="record"><tr id="type-mut_graph.graph" class="anchored"><td class="def field"><a href="#type-mut_graph.graph" class="anchor"></a><code>graph : (<span class="type-var">'v</span>, <span class="type-var">'e</span>) <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-mut_graph.add_edge" class="anchored"><td class="def field"><a href="#type-mut_graph.add_edge" class="anchor"></a><code>add_edge : <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'e</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> unit;</code></td></tr><tr id="type-mut_graph.remove" class="anchored"><td class="def field"><a href="#type-mut_graph.remove" class="anchor"></a><code>remove : <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> unit;</code></td></tr></table><code>}</code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-mk_mut_tbl"><a href="#val-mk_mut_tbl" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>mk_mut_tbl : eq:(<span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> bool) <span class="keyword">&#8209;&gt;</span> ?&#8288;hash:(<span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> int) <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'v</span>, <span class="type-var">'a</span>) <a href="index.html#type-mut_graph">mut_graph</a></code></div><div class="doc"><p>Make a new mutable graph from a Hashtbl. Edges are labelled with type <code class="code">'a</code>.</p></div></div><h3>Immutable Graph</h3><p>A classic implementation of a graph structure on totally ordered vertices,
with unlabelled edges. The graph allows to add and remove edges and vertices,
and to iterate on edges and vertices.</p><div class="spec module-type" id="module-type-MAP"><a href="#module-type-MAP" class="anchor"></a><div class="def module-type"><code><span class="keyword">module type </span><a href="module-type-MAP/index.html">MAP</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="doc"></div></div><div class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><div class="def module"><code><span class="keyword">module </span><a href="Map/index.html">Map</a> : <span class="keyword">functor</span> (<a href="Map/index.html#argument-1-O">O</a> : Map.OrderedType) -&gt; <a href="index.html#module-type-MAP">MAP</a><span class="keyword"> with </span><span class="keyword">type </span><a href="Map/index.html#type-vertex">vertex</a><span class="keyword"> = </span><a href="Map/index.html#argument-1-O">O</a>.t</code></div><div class="doc"></div></div><h3>Misc</h3><div class="spec val" id="val-of_list"><a href="#val-of_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_list : eq:(<span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> bool) <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'v</span><span class="keyword"> * </span><span class="type-var">'v</span>) list <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'v</span>, unit) <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">of_list l</code> makes a graph from a list of pairs of vertices.
Each pair <code class="code">(a,b)</code> is an edge from <code class="code">a</code> to <code class="code">b</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">eq</span>: equality used to compare vertices.</li></ul></div></div><div class="spec val" id="val-of_hashtbl"><a href="#val-of_hashtbl" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_hashtbl : (<span class="type-var">'v</span>, <span class="type-var">'v</span> list) Hashtbl.t <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'v</span>, unit) <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">of_hashtbl tbl</code> makes a graph from a hashtable that maps vertices
to lists of children.</p></div></div><div class="spec val" id="val-of_fun"><a href="#val-of_fun" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>of_fun : (<span class="type-var">'v</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'v</span> list) <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'v</span>, unit) <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">of_fun f</code> makes a graph out of a function that maps a vertex to
the list of its children. The function is assumed to be deterministic.</p></div></div><div class="spec val" id="val-divisors_graph"><a href="#val-divisors_graph" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>divisors_graph : (int, unit) <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">n</code> points to all its strict divisors.</p></div></div></body></html>